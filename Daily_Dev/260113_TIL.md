# 💭 2026-01-13 (Tue) TIL

## 🌱 Todo

### 코테 준비
- ✔️ ~~**solved.ac class 2** 4문제~~
  - ☑️ 10799, 10798, 2563, 10845
  
- **자료구조** 
  - 이차원 배열
  - 파이썬 클래스와 객체 지향 (OOP)

✔️ ~~새싹(SeSAC) 강의 진도 따라가기~~

✔️ ~~자기소개서 손대기~~

...

## 🎧 간단 정리


## 1. 일급 객체와 데코레이터

- 파이썬에서 함수는 **일급 객체(First-class object)**
- 함수를 변수에 담거나, 리스트에 넣거나, 다른 함수의 인자로 전달할 수 있음

  ```python
  # 함수를 리스트에 담아 사용 가능
  lst = [sum, max, min]
  for fun in lst:
      print(fun([1, 2, 3]))
  ```

### 데코레이터 (Decorator)

기존 함수의 코드를 수정하지 않고 새로운 기능을 추가할 때 사용

```python
def trace(func):
    def wrapper(*args, **kwargs):
        print(f'{func.__name__} 함수 시작')
        result = func(*args, **kwargs)
        print(f'{func.__name__} 함수 종료')
        return result
    return wrapper

@trace
def hello():
    print("안녕하세요!")

```

---

## 2. 클래스 속성 관리 (Getter & Setter)

데이터를 보호하고 가공된 값을 안전하게 제공하기 위해 사용

* **`@property` (Getter)**: 메서드를 변수처럼 접근(괄호 없이 실행 가능), 내부 데이터를 직접 노출하지 않고 가곡된 값을 반환하거나 읽기 전용 속성을 만들 수 있음
* **`@변수명.setter` (Setter)**: 값을 할당할 때 유용성 검사(Validation)

```python
class Person:
    def __init__(self, age):
        self._age = age  
        # _언더바: 내부 변수임을 암시 (캡슐화), Setter를 통해서 바꿀 수 있음

    @property
    def age(self):
        return self._age

    @age.setter
    def age(self, value):
        if value < 0:
            print("❌ 음수는 나이로 설정할 수 없습니다.")
        else:
            self._age = value

```

---

## 3. 클래스 메서드와 정적 메서드

| 종류 | 데코레이터 | 특징 |
| --- | --- | --- |
| **인스턴스 메서드** | (없음) | `self`를 통해 인스턴스 변수에 접근 |
| **클래스 메서드** | `@classmethod` | `cls`를 통해 클래스 변수에 접근 |
| **정적 메서드** | `@staticmethod` | 클래스 안에 있지만 독립적인 기능을 수행 |

---

## 4. 클래스 상속과 오버라이딩

* **오버라이딩**: 부모의 메서드를 자식 클래스에서 재정의
* **`super()`**: 부모 클래스의 기능을 그대로 가져와서 확장할 때 사용.

  ```python
  class Person:
      def __init__(self, name):
          self.name = name

  class Developer(Person):
      def __init__(self, name, language):
          super().__init__(name)  # 부모의 생성자 호출
          self.language = language
  ```

> **다중 상속의 순서**: `class Ex(A, B)`일 경우, 동일한 메서드가 있다면 먼저 인자로 넣은 `A`의 메서드를 우선적으로 실행

---

## 5. 2차원 배열 선언 시 주의사항 (얕은 복사)

2차원 배열을 만들 때 **객체 참조의 특성** 이해 필요

### ❌ 잘못된 방법: `[[0]*10]*10`

* `[0]*10`으로 만들어진 **하나의 리스트 객체**를 10번 복사함.
* 모든 행이 **동일한 메모리 주소**를 가리키므로, 한 행을 바꾸면 전체가 바뀜. (통로 하나로 연결된 10개의 방)

### ✅ 올바른 방법: 리스트 컴프리헨션

```python
paper = [[0] * 10 for _ in range(10)]
```

* `for` 루프가 돌 때마다 **새로운 리스트 객체**를 생성하므로 각 행이 독립적임.

### 💡 1차원 배열 `[0]*10`은 왜 괜찮을까?

* 숫자(`0`)는 **불변(Immutable)** 객체이기 때문. 값을 바꿀 때 주소 자체가 교체되므로 다른 칸에 영향을 주지 않음. 반면 리스트는 **가변(Mutable)** 객체라 내부 값이 바뀌면 공유하는 모든 곳에 영향.

...

## 🐚 회고

**쇠막대기 문제 아예 ai 하나도 안쓰고 풀었다!!**

**프로젝트 기억나는거 이동하면서 틈틈히 메모장에 쓰고 내일 와서 옮기자**

**프로젝트 내용, 목적, 주요 업무 및 상세 역할, 사용언어 및 개발환경, 해결한 문제, 배운점**

**포트폴리오는 언제 또 하냐..**

...

```
### 내일 목표 (To-Do) ###

□ **원형 큐(Circular Queue) 구현**: 
오늘 구현한 일반 큐를 넘어서, 메모리를 효율적으로 관리하는 원형 큐를 직접 설계하고 구현해보기.

□ **프로젝트 메모 업데이트**: 
생각날 때마다 메모장에 기록해둔 프로젝트 경험들을 정식 문서로 옮기기.
```