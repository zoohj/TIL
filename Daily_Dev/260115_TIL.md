# 💭 2026-01-15 (Thu) TIL

## 🌱 Todo

### 코테 준비
- □ **solved.ac class 2** 5문제 
  - ☑️ 1018
  - ✍️ 1874, 1913(달팽이), 10845(Que)      

✔️ ~~새싹(SeSAC) 강의 진도 따라가기~~
- 자판기 설계

...

## 🎧 간단 정리


### 알고리즘

### 💡 체스판 문제

**1. 고정된 정답(패턴)을 먼저 정의하기**

* 체스판은 아무리 넓어도 정답지(Target)가 단 2개뿐임
* **패턴 A:** 왼쪽 위가 'W'로 시작하는 정답지
* **패턴 B:** 왼쪽 위가 'B'로 시작하는 정답지

* "어떻게 칠할까?"를 고민하지 말고, **"이미 완성된 정답지와 지금 내 보드가 얼마나 다른가?"** 로 관점을 전환

**2. 좌표의 '홀짝 성질' 활용하기 (Parity Check)**

*  2*2 단위로 반복되는 격자 구조에서 가장 강력한 도구: **행(r)과 열(c)의 인덱스 합**
*  `(r+c) mod 2` 의 결과가 같다면, 그 칸들은 체스판에서 반드시 같은 색
   * 합이 **0, 2, 4... (짝수)**인 칸들의 그룹
   * 합이 **1, 3, 5... (홀수)**인 칸들의 그룹


* 복잡한 `if-else` 없이도 현재 칸이 정답과 일치하는지 판별 가능

**3. 완전 탐색(Brute Force)의 범위 결정**

* "모든 경우를 다 해봐도 시간 안에 끝날까?"를 먼저 계산
* `n, m`이 최대 50일 때, 8*8로 자를 수 있는 모든 시작점을 잡고 전수 조사해도 연산 횟수가 매우 적으므로(약 16만 번), 가장 단순하고 확실한 **완전 탐색**을 선택

---

### 파이썬 심화 기초 및 객체지향 설계

### 1. 타입 힌팅 (Type Hinting)

코드의 가독성을 높이고, 함수가 어떤 데이터를 다루는지 명확히 명시

* **사용 이유**: 협업 시 다른 개발자가 함수에 어떤 객체를 넣어야 할지 바로 알 수 있고, 에러를 사전에 방지
* **예시**: `def print_user_info(user: User) -> None:`
* `user: User`: 인자 `user`는 `User` 클래스의 인스턴스여야 함을 의미.
* `-> None`: 이 함수는 반환값(return)이 없음을 의미.



### 2. 객체 연결과 상호작용 (Object Collaboration)

객체끼리 연결하는 것이 어려운 이유는 "누가 먼저 말을 걸어야 하는가"가 헷갈리기 때문

* **설계 원칙**: 각 객체는 **자신의 상태를 바꾸는 행동**만 함수로 가짐
* 자판기: 자신의 재고를 줄이는 함수 (`decrease_stock`)
* 고객: 자신의 돈을 줄이는 함수 (`spend_money`)


* **연결 방법**: 상위 매니저 로직이나 고객 객체에서 **상대방 객체를 인자로 받아** 상대방의 함수를 호출
> **Tip**: "A가 B의 함수를 호출한다" == A가 B에게 **메시지를 보낸다**


### 3. 예외 처리 (Exception Handling)

프로그램이 예상치 못한 상황에서 멈추지 않도록

* **기본 구조**:
* `try`: 에러가 날 것 같은 위험한 코드 실행.
* `except`: 에러 발생 시 처리할 로직 (프로그램 종료 방지).


* **사용자 정의 에러 (Custom Error)**:
* 파이썬 기본 에러(`ValueError`, `IndexError` 등) 외에, 우리 서비스만의 구체적인 에러 상황을 정의할 때 사용


### 4. 오늘의 깨달음: 행동 중심 설계

함수를 어디에 넣을지 모르겠을 때는 "**그 행동으로 인해 데이터가 변하는 주인**"에게 함수를 주면 됨

* 돈이 줄어드는 건 고객인가요, 자판기인가요? -> 고객에게 `pay()` 함수를!
* 재고가 줄어드는 건 상품인가요, 자판기인가요? -> 자판기에게 `sell()` 함수를!


#### 좌표 이동
```python
dx = [0, 0, 1, -1]
dy = [1, -1, 0, 0]
x = 0
y = -1
                           
for d in range(4):
    nx = x + dx[d]
    ny = y + dy[d]
    print(nx,ny)

nx = x + dx[0]

x = nx
```

---

## 💡 객체지향으로 자판기 시스템 설계

### 1. 객체의 역할 분담 (Responsibility)

객체지향 설계의 핵심은 "누가 이 정보를 알고 있으며, 누가 행동하는가?"를 정의하는 것.

* **Product (상품)**: 이름, 가격, 재고(`stock`) 정보를 가진 데이터 객체.
* **VendingMachine (자판기)**: 여러 상품을 관리(`List`, `Map`)하고, 판매 로직(재고 확인, 결제 요청, 상품 배출)을 담당.
* **Customer (고객)**: 소지하고 있는 돈(`balance`)과 결제 수단을 가지며, 구매 행동을 시작하는 주체.

### 2. 다중 상품 관리와 고유 번호

* **리스트 활용**: 자판기 내부에 `self.products = [a, b, c]`와 같이 상품 객체들을 리스트로 관리.
* **식별자(ID)**: 상품 고유의 ID와 자판기 슬롯 번호(인덱스)를 구분하여 관리하면 유연성이 높아짐.
* **순회와 조회**: `enumerate()`를 사용하여 사용자에게 선택 번호를 제공하고, 인덱스를 통해 리스트에서 객체를 직접 꺼내오는 방식이 효율적.

### 3. 상태(State)에 따른 제어

* 자판기는 현재 돈이 들어온 상태인지, 재고가 있는지 등 **상태**에 따라 행동이 달라짐.
* `is_active` 같은 플래그나 재고 수량(`stock`)을 확인하여 구매 가능 여부를 사전에 필터링하는 '방어적 코드' 작성이 중요.

### 4. 객체 간의 상호작용 (Interaction)

* **객체 전달**: 함수에 숫자나 문자열만 넘기는 게 아니라, **객체 자체**를 인자로 넘겨 서로 대화하게 함.
* 예: `customer.insert_money(machine, amount)` -> 고객이 자판기라는 '객체'에게 돈을 전달.


* **결제 다형성**: `Card`, `Cash` 등 결제 수단을 별도 클래스로 분리하고, 자판기는 어떤 수단이든 상관없이 `pay()`라는 공통 메서드를 호출하여 결제를 처리함. (확장성 확보)

### 5. 핵심 로직 흐름 (Code Flow)

1. **조회(`show_items`)**: 현재 판매 중인 상품 목록과 인덱스를 출력.
2. **선택(`choose_item`)**: 사용자 입력을 받아 리스트에서 상품을 선택하고, 재고 유무를 판단하여 **(성공여부, 상품객체)**를 반환.
3. **결제 및 배출**: 반환된 결과를 바탕으로 결제를 진행하고, 성공 시에만 재고를 차감.

---

### 💡 오늘의 깨달음

> "객체지향은 단순히 기능을 나누는 것이 아니라, 현실 세계의 상호작용을 코드로 옮기는 과정이다. 데이터를 가진 객체가 그 데이터를 처리하는 행동(함수)을 가질 때 가장 자연스러운 코드가 나온다."



...

## 🐚 회고
**gg**