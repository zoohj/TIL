# 💭 2026-02-05 (Thu) TIL

## 🌱 Todo

### 코테 준비
- □ **solved.ac class 3** 3문제 
  - ☑️ 2346
  - ✍️ 1874(수열), 공통문제 - [2493]
      
- **자료구조** 
  - 스택
  - 큐


- ✔️ ~~새싹(SeSAC) 강의 진도 따라가기~~
  - fastapi - db 연결

...

## 🎧 간단 정리

### [FastAPI]

### 데이터 검증 및 필드 제어
> **Pydantic field_validator**
- 특정 필드, 사용자정의 로직 실행하는 데코레이터
- 반드시, classmethod & 검증 통과값 return

- **단일 필드 검증** : 특정 문자열 포함여부나 형식 검증
  <details>

  ```python
  from pydantic import BaseModel, field_validator

  class TransferCreate(BaseModel):
      amount: int
      account_number: str

      @field_validator('amount')
      @classmethod
      def validate_amount_unit(cls, v: int) -> int:
          if v % 100 != 0:
              raise ValueError("이체 금액은 100원 단위로 입력해야 합니다.")
          return v

      @field_validator('account_number')
      @classmethod
      def validate_account_format(cls, v: str) -> str:
          if "-" not in v:
              raise ValueError("계좌번호는 하이픈(-)을 포함해야 합니다.")
          return v
  ```

  </details>



- **필드 간 비교 검증** : 두 필드 값 일치해야 하는 경우 
  <details>

  ```python
  from pydantic import BaseModel, field_validator, ValidationInfo

  class Signup(BaseModel):
      email: str
      confirm_email: str

      @field_validator('confirm_email')
      @classmethod
      def check_emails_match(cls, v: str, info: ValidationInfo) -> str:
          # info.data를 통해 먼저 검증된 'email' 필드 값에 접근
          if 'email' in info.data and v != info.data['email']:
              raise ValueError("이메일이 일치하지 않는다.")
          return v
  ```

  </details>



> **Response Model**
-
  <details>
  <summary>기존 방식</summary>

  ```python

  @router.get("/posts", response_model=list[PostResponse])
  def get_posts():
      # FastAPI는 리턴 타입 힌트를 보고 자동으로 response_model을 설정한다.
      return post_service.get_all_posts()

  ```
  </details>

- return type 강제



- 리턴 타입 힌트 활용하여 return type과 response model이 정확히 같아야함


  ```python
  @router.get("/posts")
  def get_posts() -> list[PostResponse]:
      return post_service.get_all_posts()
  ```


### 알고리즘

> **BOJ 2493 ― 탑**

너무 어렵다.. 일주일 후에 다시 풀어보기 

<details>
<summary>top 문제 정리 </summary>

## 📌 문제 요약

* 각 탑이 **왼쪽 방향으로 동시에 레이저 신호**를 보냄
* 레이저는

  * 자기보다 **왼쪽**
  * **높이가 크거나 같은**
  * **가장 가까운 탑**에서 처음 수신됨
* 각 탑마다 그 탑의 **번호(1-based)** 출력
* 없으면 `0`

---

## ❌ 처음 떠올리기 쉬운 접근

* 각 탑마다 왼쪽을 끝까지 탐색
* 시간복잡도: **O(N²)** → N 최대 500,000 → 시간초과

---

## ✅ 핵심 관찰 (이 문제의 본질)

> **나보다 낮은 왼쪽 탑은
> 앞으로 절대 답이 될 수 없다**

이유:

* 더 오른쪽에 있고
* 더 높은 탑이 등장하면
* 낮은 탑은 영원히 가려짐

👉 **쓸모없는 과거는 즉시 버린다**

---

## 🧠 해결 전략 ― 스택

### 스택에 들어가는 의미

* **아직 살아남은 왼쪽 탑 후보들**
* `(인덱스, 높이)` 형태

---

## 🔁 처리 흐름 (왼쪽 → 오른쪽, 한 번만)

현재 탑을 볼 때:

1️⃣ **while**

* 스택 top의 높이 < 현재 탑 높이
  → pop (쓸모 없음)

2️⃣ **정답 결정**

* 스택 비어 있음 → `0`
* 아니면 → `stack[-1].index + 1`

3️⃣ **push**

* 현재 탑을 스택에 추가

👉 각 탑은 **push 1번 + pop 최대 1번**
👉 전체 시간복잡도 **O(N)**

---

## ✍️ 의사코드

```
for i in 0..N-1:
    while stack not empty and stack.top.height < height[i]:
        pop
    if stack empty:
        answer[i] = 0
    else:
        answer[i] = stack.top.index + 1
    push (i, height[i])
```

---

## 🧩 예시

입력:

```
6 9 5 7 4
```

출력:

```
0 0 2 2 4
```

---

## 💡 사고 전환 포인트 (중요)

* ❌ “각 탑마다 왼쪽을 다시 본다”
* ✅ “다시 쓸 수 없는 왼쪽 탑을 미리 제거한다”

---

## 🔗 함께 묶어 연습하면 좋은 문제

* BOJ 17298 ― 오큰수
* BOJ 6198 ― 옥상 정원 꾸미기
* BOJ 3015 ― 오아시스 재결합

👉 **전부 같은 스택 사고**

---

## ⭐ 한 줄 요약

> **2493은 ‘스택을 쓰는 문제’가 아니라
> ‘쓸모없는 과거를 버리는 문제’다**

</details>


> **BOJ 2346 ― 풍선 터뜨리기**
- 💡
  * 원형 구조 → **deque**
  * 이동 → **rotate**
  * 터뜨린 순간 **이미 1칸 이동한 상태**


- 이동 규칙 

  deque.rotate 기준:

  * `rotate(k)`  → 오른쪽
  * `rotate(-k)` → 왼쪽

  문제 이동 방향과 **부호가 반대**임

...


## 🐚 회고
**비록 골드는 못풀었지만.. 다른 문제들을 많이 풀어보고 실력을 키우자.**