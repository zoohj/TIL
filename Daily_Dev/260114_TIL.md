# 💭 2026-01-14 (Wed) TIL

## 🌱 Todo

### 코테 준비
- □ **solved.ac class 2** 6문제 
  - ☑️ 11650, 10773
  - ✍️ 1874, 1018, 1913(달팽이), 10845(Que)      
  
- **자료구조** 
  - OOP, 추상화

✔️ 새싹(SeSAC) 강의 진도 따라가기 

...

## 🎧 간단 정리

### 객체지향 설계(OOP)와 자료구조(Stack)의 이해

### 1. 스택(Stack) 자료구조와 수열 문제

* **핵심 원리:** LIFO(Last In, First Out) - 나중에 들어간 것이 먼저 나온다.
* **문제 핵심:** 1부터 까지 **오름차순으로만 Push**가 가능하다는 제약 조건 속에서, 주어진 수열을 `pop` 연산으로 만들어낼 수 있는지 판단하는 것이 포인트.
* **주의할 점:** 스택을 인덱스로 접근할 때, 스택 안에 원소가 있는지 확인 필수. 스택의 `top`(`stack[-1]`)이 내가 뽑아야 할 숫자보다 크다면, 그 수열은 절대 만들 수 없는 수열(`NO`)이 된다.

### 2. 파이썬 추상 클래스 (ABC)

* **개념:** 미완성 설계도. 직접 객체를 생성할 수 없으며 상속을 통해서만 사용 가능.
* **문법:** `from abc import ABC, abstractmethod`를 사용하며, `@abstractmethod`가 붙은 메서드는 자식 클래스에서 **반드시** 구현해야 함.
* **효과:** 협업 시 강제성을 부여하여 코드의 일관성을 유지함.




<details>
<summary> 게임 캐릭터 설계 예시 코드</summary>

```python
# character.py

class Charater:

    def __init__(self, name, job):
        self.name = name
        self.job = job
        self.weapon = None

    def attack(self):
        print(self.name)
        self.job.attack()


    def equip_weapon(self, weapon):
        # if self.job이 weapon을 안받아드려? 그럼 못껴
        if type(weapon) not in self.job.allow_weapons:
            # is_instance() 함수가 존재해요 -> 이거를 사용하는게 좀 더 안전한 방법
            print('착용 불가능합니다')
            return
        print(f'{weapon.name} 무기를 착용했습니다!')
        self.weapon = weapon

    def use_skill(self):
        # weapon에 따라 달라집니다.
        if self.weapon is not None:
            self.weapon.skill()
            return
        print('착용된 무기가 없어서 스킬 못써요!')        
```

```python
### job.py 

from abc import ABC, abstractmethod
from weapon import Sword, Wand
class Job(ABC):
    @abstractmethod
    def attack(self):
        pass

class Warrier(Job):
    allow_weapons = [Sword]

    def __str__(self):
        return '전사'
    
    def attack(self):
        print('전사의 공격')
    

class Mage(Job):
    allow_weapons = [Wand]

    def attack(self):
        print('마법사의 공격')
```
```python
### weapon.py 

from abc import ABC, abstractmethod

class Weapon(ABC):

    def __init__(self, name):
        self.name = name

    @abstractmethod    
    def skill(self):
        pass

class Sword(Weapon):
    def skill(self):
        print(f'울부짖어라 {self.name}')

class Wand(Weapon):
    def skill(self):
        print(f'흩날려라 {self.name}')
```
```python
### main.py 

from charater import Charater
from job import  Warrier, Mage
from weapon import Sword, Wand

me = Charater('아서', Warrier())
you = Charater('멀린', Mage())

sword = Sword('쌍고검')
wand = Wand('딱총나무 지팡이')

me.attack()
you.attack()

me.use_skill()

me.equip_weapon(sword)
me.use_skill()

me.equip_weapon(wand)
you.equip_weapon(wand)

me.job = Mage()
```

</details>





### 3. 객체지향 설계의 3요소 (Refactoring 포인트)

| 원칙 | 설명 | 적용 사례 |
| --- | --- | --- |
| **단일 책임 원칙 (SRP)** | 한 클래스는 하나의 역할만 수행 | 캐릭터, 직업, 무기 클래스를 각각 독립적으로 분리 |
| **합성 (Composition)** | 상속보다 유연한 객체 간의 결합 | `Character`가 `Job` 객체를 속성으로 가져서 전직이 용이함 |
| **다형성 (Polymorphism)** | 같은 명령에 객체마다 다르게 반응 | `attack()` 호출 시 직업에 따라 다른 공격 메시지 출력 |

💡 **상속보단 합성**

### 4. 코드 개선 전 vs 후

* **전:** \
캐릭터 클래스 안에서 `if-else`로 모든 상황(전사인지, 무기가 있는지)을 판단함 → **확장이 어려움.**
* **후:** \
 캐릭터는 명령만 내리고, 실제 로직은 `Job`과 `Weapon` 객체가 수행하도록 `위임(Delegation)`함 \
→ **유지보수가 쉬움.**

...

## 🐚 회고

```
" 클래스를 나누는 것은 단순히 코드를 쪼개는 것이 아니라, 
각 객체에게 알맞은 **책임**을 주는 과정 " 
```

**객체지향적으로 코드를 짠다는건 뭘까.. 너무 어렵다.. 어떻게 하면 유지보수가 쉽고 확장하기 쉬운 좋은 코드를 짤 수 있을지 고민해보자**

**알고리즘 문제는 파이썬으로 풀어보고 실버를 10분만에 풀수있고 골드 1,2 언저리 되면
자바로 바꿔서 공부하고 스프링까지 공부**


**3-4시가 너무 고비야 너무 졸려 해결할 방법 없을까나...오늘 못 푼 알고리즘 문제는 내일 풀자**

**수업시간 이외의 공부 시간을 늘려갈 필요가 있음. 내일부터 집가서 밥먹고 추가공부 하자**